-- Leo IceHub - Centered + Draggable + Resizable (Mouse & Touch + Pinch) LocalScript
-- Paste this into your GitHub file (LeoTestMenu.lua) or StarterPlayerScripts.
-- Menu starts centered: Position = UDim2.new(0.5,0,0.5,0) and AnchorPoint = (0.5,0.5).

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local StarterGui = game:GetService("StarterGui")

local localPlayer = Players.LocalPlayer
local playerGui = localPlayer:WaitForChild("PlayerGui")

-- Clean old
if playerGui:FindFirstChild("LeoIceHub_UI") then playerGui.LeoIceHub_UI:Destroy() end
if playerGui:FindFirstChild("LeoIceHub_OpenBtn") then playerGui.LeoIceHub_OpenBtn:Destroy() end

-- ---------- UI BUILD ----------
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "Leo Hub_UI"
screenGui.ResetOnSpawn = false
screenGui.Parent = playerGui
screenGui.Enabled = false -- start hidden

local main = Instance.new("Frame", screenGui)
main.Name = "Main"
main.AnchorPoint = Vector2.new(0.5, 0.5)
main.Position = UDim2.new(0.5, 0, 0.5, 0) -- EXACT center initially (user requested)
main.Size = UDim2.new(0, 420, 0, 520)
main.BackgroundColor3 = Color3.fromRGB(10,10,18)
main.BorderSizePixel = 0
main.ZIndex = 2
local mainCorner = Instance.new("UICorner", main); mainCorner.CornerRadius = UDim.new(0,14)
local mainStroke = Instance.new("UIStroke", main); mainStroke.Color = Color3.fromRGB(75,160,255); mainStroke.Thickness = 2; mainStroke.Transparency = 0.35

-- Title
local title = Instance.new("TextLabel", main)
title.Size = UDim2.new(1,0,0,48)
title.Position = UDim2.new(0,0,0,0)
title.BackgroundTransparency = 0.12
title.BackgroundColor3 = Color3.fromRGB(18,18,28)
title.Font = Enum.Font.GothamBold
title.TextSize = 20
title.Text = "Leo Hub â€¢ Neon"
title.TextColor3 = Color3.fromRGB(235,245,255)
local titleStroke = Instance.new("UIStroke", title); titleStroke.Color = Color3.fromRGB(150,200,255)

-- Close Button
local closeBtn = Instance.new("TextButton", main)
closeBtn.Name = "CloseBtn"
closeBtn.Size = UDim2.new(0,36,0,28)
closeBtn.Position = UDim2.new(1, -46, 0, 10)
closeBtn.Text = "X"
closeBtn.Font = Enum.Font.Gotham
closeBtn.TextSize = 16
closeBtn.BackgroundColor3 = Color3.fromRGB(200,70,70)
closeBtn.TextColor3 = Color3.fromRGB(255,255,255)
Instance.new("UICorner", closeBtn).CornerRadius = UDim.new(0,6)

-- Plus / Minus (resize quickly)
local plusBtn = Instance.new("TextButton", main)
plusBtn.Size = UDim2.new(0,34,0,28)
plusBtn.Position = UDim2.new(1, -92, 0, 10)
plusBtn.Text = "+"
plusBtn.Font = Enum.Font.GothamBold
plusBtn.TextSize = 18
plusBtn.BackgroundColor3 = Color3.fromRGB(60,120,255)
plusBtn.TextColor3 = Color3.fromRGB(255,255,255)
Instance.new("UICorner", plusBtn).CornerRadius = UDim.new(0,6)

local minusBtn = Instance.new("TextButton", main)
minusBtn.Size = UDim2.new(0,34,0,28)
minusBtn.Position = UDim2.new(1, -128, 0, 10)
minusBtn.Text = "-"
minusBtn.Font = Enum.Font.GothamBold
minusBtn.TextSize = 18
minusBtn.BackgroundColor3 = Color3.fromRGB(60,120,255)
minusBtn.TextColor3 = Color3.fromRGB(255,255,255)
Instance.new("UICorner", minusBtn).CornerRadius = UDim.new(0,6)

-- Left / Right placeholders (you can paste previous content here)
local left = Instance.new("Frame", main)
left.Size = UDim2.new(0.58, -12, 1, -64)
left.Position = UDim2.new(0,8,0,56)
left.BackgroundTransparency = 1

local right = Instance.new("Frame", main)
right.Size = UDim2.new(0.38, -12, 1, -64)
right.Position = UDim2.new(0.62, 4, 0, 56)
right.BackgroundTransparency = 1

-- Resizer handle (bottom-right small area)
local resizer = Instance.new("Frame", main)
resizer.Name = "Resizer"
resizer.Size = UDim2.new(0, 18, 0, 18)
resizer.AnchorPoint = Vector2.new(1,1)
resizer.Position = UDim2.new(1, -8, 1, -8)
resizer.BackgroundColor3 = Color3.fromRGB(40,40,50)
Instance.new("UICorner", resizer).CornerRadius = UDim.new(0,6)
local resizerStroke = Instance.new("UIStroke", resizer); resizerStroke.Color = Color3.fromRGB(75,160,255); resizerStroke.Thickness = 1

-- visual hint for resizer (diagonal lines)
local function makeResizerIcon(parent)
    for i=0,2 do
        local l = Instance.new("Frame", parent)
        l.Size = UDim2.new(0.6,0,0,2)
        l.AnchorPoint = Vector2.new(1,1)
        l.Position = UDim2.new(1, -4 - (i*5), 1, -4 - (i*5))
        l.BackgroundColor3 = Color3.fromRGB(120,160,255)
        l.Rotation = 45
        l.BorderSizePixel = 0
    end
end
makeResizerIcon(resizer)

-- ---------- Configs for dragging/resizing ----------
local MIN_W, MIN_H = 300, 200
local MAX_W, MAX_H = math.max(300, workspace.CurrentCamera.ViewportSize.X - 40), math.max(200, workspace.CurrentCamera.ViewportSize.Y - 80)

-- current state for dragging/resizing
local dragging = false
local dragInput = nil
local dragStart = nil
local startPos = nil

local resizing = false
local resizeInput = nil
local resizeStartPos = nil
local resizeStartSize = nil

-- For pinch-to-zoom
local touches = {} -- map of input.UserInputId -> input
local pinchActive = false
local pinchStartDist = nil
local pinchStartSize = nil

local function clampSize(w,h)
    w = math.clamp(w, MIN_W, MAX_W)
    h = math.clamp(h, MIN_H, MAX_H)
    return w,h
end

-- Convert delta (pixels) to UDim2 position offset using startPos
local function updateMainPositionByDelta(delta)
    if not startPos then return end
    local newX = startPos.X.Scale
    local newXOffset = startPos.X.Offset + delta.X
    local newY = startPos.Y.Scale
    local newYOffset = startPos.Y.Offset + delta.Y
    main.Position = UDim2.new(newX, newXOffset, newY, newYOffset)
end

-- Mouse/Touch drag start on main frame (but only when clicked in title area or entire main if desired)
main.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        -- only start dragging when clicking near top/title area (first 60 px) OR when touch anywhere
        local y = input.Position.Y
        local topY = main.AbsolutePosition.Y
        if input.UserInputType == Enum.UserInputType.MouseButton1 and y > topY + 60 then
            -- if clicked lower than 60 px with mouse, ignore (so resizer works etc)
            return
        end
        dragging = true
        dragInput = input
        dragStart = input.Position
        startPos = main.Position
        -- capture changed to stop
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
                dragInput = nil
                dragStart = nil
                startPos = nil
            end
        end)
    end
end)

-- Resizer mouse/touch
resizer.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        resizing = true
        resizeInput = input
        resizeStartPos = input.Position
        resizeStartSize = main.AbsoluteSize
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                resizing = false
                resizeInput = nil
                resizeStartPos = nil
                resizeStartSize = nil
            end
        end)
    end
end)

-- Track touches for pinch
UserInputService.InputBegan:Connect(function(input, processed)
    if input.UserInputType == Enum.UserInputType.Touch then
        touches[input.UserInputId] = input
        local count = 0 for _ in pairs(touches) do count = count + 1 end
        if count == 2 then
            -- start pinch
            local ids = {}
            for id,t in pairs(touches) do table.insert(ids, t) end
            local a,b = ids[1], ids[2]
            if a and b then
                pinchActive = true
                pinchStartDist = (a.Position - b.Position).Magnitude
                pinchStartSize = main.AbsoluteSize
            end
        end
    end
end)

UserInputService.InputChanged:Connect(function(input)
    -- dragging with mouse or touch
    if dragging and dragInput and input == dragInput then
        local delta = input.Position - dragStart
        updateMainPositionByDelta(delta)
        return
    end

    -- resizing with resizer
    if resizing and resizeInput and input == resizeInput then
        local delta = input.Position - resizeStartPos
        local newW = resizeStartSize.X + delta.X
        local newH = resizeStartSize.Y + delta.Y
        newW, newH = clampSize(newW, newH)
        main.Size = UDim2.new(0, newW, 0, newH)
        return
    end

    -- pinch update
    if input.UserInputType == Enum.UserInputType.Touch and pinchActive then
        -- update touches table for this id
        if touches[input.UserInputId] then touches[input.UserInputId] = input end
        local ids = {}
        for id,t in pairs(touches) do table.insert(ids, t) end
        if #ids >= 2 then
            local a,b = ids[1], ids[2]
            if a and b and pinchStartDist and pinchStartSize then
                local curDist = (a.Position - b.Position).Magnitude
                if curDist > 0 then
                    local scale = curDist / pinchStartDist
                    local targetW = pinchStartSize.X * scale
                    local targetH = pinchStartSize.Y * scale
                    targetW, targetH = clampSize(targetW, targetH)
                    main.Size = UDim2.new(0, math.floor(targetW+0.5), 0, math.floor(targetH+0.5))
                end
            end
        end
        return
    end
end)

UserInputService.InputEnded:Connect(function(input)
    -- stop dragging if pointer ended
    if dragging and dragInput and input == dragInput then
        dragging = false; dragInput = nil; dragStart = nil; startPos = nil
    end
    -- stop resizing
    if resizing and resizeInput and input == resizeInput then
        resizing = false; resizeInput = nil; resizeStartPos = nil; resizeStartSize = nil
    end
    -- remove touches
    if input.UserInputType == Enum.UserInputType.Touch then
        touches[input.UserInputId] = nil
        local count = 0 for _ in pairs(touches) do count = count + 1 end
        if count < 2 then
            pinchActive = false
            pinchStartDist = nil
            pinchStartSize = nil
        end
    end
end)

-- Plus / Minus quick resize (10% steps)
local function applyScale(factor)
    local cur = main.AbsoluteSize
    local targetW = cur.X * factor
    local targetH = cur.Y * factor
    targetW, targetH = clampSize(targetW, targetH)
    main.Size = UDim2.new(0, math.floor(targetW+0.5), 0, math.floor(targetH+0.5))
end
plusBtn.MouseButton1Click:Connect(function() applyScale(1.1) end)
minusBtn.MouseButton1Click:Connect(function() applyScale(0.9) end)

-- Make sure MAX uses current viewport
local function updateMax()
    MAX_W = math.max(300, workspace.CurrentCamera.ViewportSize.X - 40)
    MAX_H = math.max(200, workspace.CurrentCamera.ViewportSize.Y - 80)
end
workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(updateMax)
UserInputService.WindowFocused:Connect(updateMax)
RunService.Heartbeat:Connect(function() end)

-- ---------- Open button (bottom-right) ----------
local openBtn = Instance.new("TextButton", playerGui)
openBtn.Name = "LeoIceHub_OpenBtn"
openBtn.Size = UDim2.new(0, 72, 0, 72)
openBtn.AnchorPoint = Vector2.new(1, 1)
openBtn.Position = UDim2.new(1, -20, 1, -20)
openBtn.BackgroundColor3 = Color3.fromRGB(20,20,30)
openBtn.Text = "ICE"
openBtn.Font = Enum.Font.GothamBold
openBtn.TextSize = 18
openBtn.TextColor3 = Color3.fromRGB(200,240,255)
Instance.new("UICorner", openBtn).CornerRadius = UDim.new(0, 18)
local openStroke = Instance.new("UIStroke", openBtn); openStroke.Color = Color3.fromRGB(75,160,255); openStroke.Thickness = 2

local animFlag = false
local tweenInfoIn = TweenInfo.new(0.32, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
local tweenInfoOut = TweenInfo.new(0.26, Enum.EasingStyle.Quad, Enum.EasingDirection.In)

local function showMenu()
    if animFlag then return end
    animFlag = true
    screenGui.Enabled = true
    openBtn.Visible = false
    updateMax()
    -- ensure start anchored center
    main.AnchorPoint = Vector2.new(0.5,0.5)
    -- set immediate position slightly below with tween to center to make smooth effect, final must be exactly 0.5,0.5
    main.Position = UDim2.new(0.5, 0, 0.5, 40)
    local tw = TweenService:Create(main, tweenInfoIn, {Position = UDim2.new(0.5, 0, 0.5, 0)})
    tw:Play()
    tw.Completed:Wait()
    animFlag = false
end

local function hideMenu()
    if animFlag then return end
    animFlag = true
    local tw = TweenService:Create(main, tweenInfoOut, {Position = UDim2.new(0.5, 0, 1.6, 0)})
    tw:Play()
    tw.Completed:Wait()
    screenGui.Enabled = false
    openBtn.Visible = true
    -- reset main position to exactly center (requested)
    main.Position = UDim2.new(0.5, 0, 0.5, 0)
    animFlag = false
end

openBtn.MouseButton1Click:Connect(showMenu)
closeBtn.MouseButton1Click:Connect(hideMenu)

-- Insert key toggle
UserInputService.InputBegan:Connect(function(input, gp)
    if gp then return end
    if input.KeyCode == Enum.KeyCode.Insert then
        if screenGui.Enabled then hideMenu() else showMenu() end
    end
end)

-- Ensure main stays visible when viewport changes (clamp size if necessary)
workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
    updateMax()
    local abs = main.AbsoluteSize
    local w,h = clampSize(abs.X, abs.Y)
    main.Size = UDim2.new(0, w, 0, h)
end)

-- Prevent accidental selection when dragging on mobile (optional)
main.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.Touch then
        input:Capture()
    end
end)

-- OPTIONAL: expose API if loadstring used
local api = {
    Show = showMenu,
    Hide = hideMenu,
    SetSize = function(w,h) w,h = clampSize(w,h) main.Size = UDim2.new(0, w, 0, h) end,
    Center = function() main.Position = UDim2.new(0.5,0,0.5,0); main.AnchorPoint = Vector2.new(0.5,0.5) end
}

-- return API when used via loadstring
return api
